#!/bin/python
import sys
import requests
import os
import json
import dataclasses
import subprocess
import inspect

from urllib.parse import quote_plus
from typing import Any, Callable, override

args = sys.argv

server = os.environ.get("AIO_SERVER", "http://localhost:8080")
apiPath = server + os.environ.get("API_PATH", "/api/v1")

def buildTable(items: dict[Any, Any], kvsep: str = " : "):
    lines: list[tuple[str, str]] = [(k, v) for k, v in items.items()]

    longestKey = max(*lines, key=lambda x: len(x[0]))
    lkLen = len(longestKey[0])

    text = "\n".join(f"{k: <{lkLen}}{kvsep}{v}" for k, v in lines)
    return text

@dataclasses.dataclass
class User:
    ItemId: int
    Status: str
    ViewCount: int
    UserRating: float
    Notes: str
    CurrentPosition: str

    @override
    def __repr__(self) -> str:
        return str(buildTable(self.__dict__))

@dataclasses.dataclass
class Meta:
    ItemId: int
    Rating: float
    RatingMax: float
    Description: str
    ReleaseYear: int
    Thumbnail: str
    MediaDependant: str
    Datapoints: str
    Title: str
    Native_Title: str
    Provider: str
    ProviderID: str

    @override
    def __repr__(self) -> str:
        return str(buildTable(self.__dict__))


@dataclasses.dataclass
class Entry:
    ItemId: int
    Collection: str
    En_Title: str
    Native_Title: str
    Format: int
    Location: str
    PurchasePrice: float
    ParentId: int
    Type: str
    ArtStyle: int
    CopyOf: int

    @override
    def __repr__(self) -> str:
        return str(buildTable(self.__dict__))

@dataclasses.dataclass
class Items:
    entries: list[Entry] = dataclasses.field(default_factory=list)
    user: list[User] = dataclasses.field(default_factory=list)
    meta: list[Meta] = dataclasses.field(default_factory=list)

    def orderizeLists(self):
        """
        Ensures all lists are in the same order
        """
        self.entries = sorted(self.entries, key=lambda item: item.ItemId)
        self.meta = sorted(self.meta, key=lambda item: item.ItemId)
        self.user = sorted(self.user, key=lambda item: item.ItemId)
        return self

items = Items()

def setArgc(count: int=1):
    def accept_fn(fn: Callable[..., Any]):
        setattr(fn, "_aio_argc", count)
        return fn
    return accept_fn

def parseJsonL(jsonl: str, constructor: object):
    if not callable(constructor):
        return []
    return [constructor(**json.loads(jsonLine)) for jsonLine in jsonl.split("\n") if jsonLine]

def fetchDataList(endpoint: str, constructor: object):
    res = requests.get(endpoint)
    return parseJsonL(res.text, constructor)

def fetchUserData(): return fetchDataList(f"{apiPath}/engagement/list-entries", User)
def fetchMetaData(): return fetchDataList(f"{apiPath}/metadata/list-entries", Meta)

def action_all(items: Items):
    """
    Loads all entries
    """
    res = requests.get(f"{apiPath}/list-entries")
    items.entries = parseJsonL(res.text, Entry)
    items.user = fetchUserData()
    items.meta = fetchMetaData()
    return items.orderizeLists()

action_a = action_all

def action_select(items: Items):
    """
    Selects 1+ entries using fzf
    """
    fileName = "/tmp/aio2-tmp-fzf-items"
    with open(fileName, "w") as f:
        f.write("\n".join(f"{x.En_Title} ({x.Type}): {x.ItemId}" for x in items.entries))
    with open(fileName, "r") as f:
        text = subprocess.check_output(["fzf", "-m"], stdin=f).decode('utf-8')
    ids = {int(line.split(":")[1].strip()) for line in text.split("\n") if line}

    return Items(
        entries = list(filter(lambda x: x.ItemId in ids, items.entries)),
        user    = list(filter(lambda x: x.ItemId in ids, items.user)),
        meta    = list(filter(lambda x: x.ItemId in ids, items.meta))
    )

action_s = action_select

@setArgc(count=1)
def action_filter(items: Items, filterString: str):
    """
    Filters items that have been loaded using a python expression

    e = current entry
    u = current user entry
    m = current metadata entry
    """
    new = Items()
    for e, u, m in zip(items.entries, items.user, items.meta):
        if eval(filterString, {}, {"e": e, "u": u, "m": m}):
            new.entries.append(e)
            new.user.append(u)
            new.meta.append(m)
    return new

action_f = action_filter

def isValidFormat(formats: list[str], format: str):
    if format.endswith("+DIGITAL"):
        format = format.replace("+DIGITAL", "")
    return format in formats

def isValidArtStyle(styles: list[str], style: str):
    for s in style.split("|"):
        if s.strip() not in styles:
            return False
    return True

def action_delete(items: Items):
    """
    Deletes all selected items
    """
    confirmation_action_loop(items, "/delete-entry", "delete")
    return items

def action_location(items: Items):
    """
    Sets the location of all selected items
    """
    for item in items.entries:
        input(f"Press enter to set location for {item.En_Title}")
        location = subprocess.check_output(["fzf", "-m", "--walker-root=/"]).decode('utf-8')
        res = requests.get(f"{apiPath}/mod-entry?id={item.ItemId}&location={quote_plus(location)}")
        print(res.text)
    return items

def action_fetch_metadata(items: Items):
    """
    Fetches metadata for all items with an automatically chosen provider
    """
    confirmation_action_loop(items, "/metadata/fetch", "fetch metadata for (this will overwrite all current metadata)")
    return items

globals()["action_fetch-meta"] = action_fetch_metadata

def action_new(items: Items):
    """
    Creates a new entry
    """

    res = requests.get(f"{apiPath}/type/type")
    types = res.json()

    res = requests.get(f"{apiPath}/type/format")
    formats = res.json()
    fmtNames = {v: k for k, v in formats.items()}

    res = requests.get(f"{apiPath}/type/artstyle")
    artStyles = res.json()
    artStyleNames = {v: int(k) for k, v in artStyles.items()}

    name = input("Title: ")

    validStatuses = ["Planned", "Finished", "Dropped", "Paused", "ReViewing", ""]
    status = input("Status: ")
    while status not in validStatuses:
        status = input("Status: ")

    print(f"Valid types: {", ".join(types)}")
    entryTy = input("Type: ")
    while entryTy not in types:
        entryTy = input("Type: ")

    print(f"Valid formats: {", ".join(fmtNames)}")
    fmt = input("Format: ").upper()
    while not isValidFormat(list(fmtNames), fmt):
        fmt = input("Format: ").upper()

    digital = fmt.endswith("+DIGITAL")
    if digital:
        fmt = fmt.replace("+DIGITAL", "")

    fmtNum = int(fmtNames[fmt])

    print(f"Valid art styles: {", ".join(artStyleNames)}")
    print("Combine art styles with |")
    userArtStyles = input("Art styles: ")
    while not isValidArtStyle(list(artStyleNames), userArtStyles):
        userArtStyles = input("Art styles: ")

    artStyleNum = sum(artStyleNames[style.strip()] for style in userArtStyles.split("|"))

    purchasePrice = input("Purchase price: ")
    try:
        price = float(purchasePrice)
    except ValueError:
        print("[WARNING]: invalid price, using 0")
        price = 0

    tags = input("tags (, seperated)")

    queries = {
        "price": str(price),
        "format": str(fmtNum),
        "is-digital": str(digital).lower(),
        "art-style": str(artStyleNum),
        "tags": tags,
        "type": entryTy,
        "user-status": status
    }

    url = f"{apiPath}/add-entry?title={quote_plus(name)}"
    for k, v in queries.items():
        url += f"&{k}={quote_plus(v)}"
    res = requests.get(url)

    newEntry = Entry(**res.json())
    newUser = list(filter(lambda item: item.ItemId == newEntry.ItemId, fetchUserData()))[0]
    newMeta = list(filter(lambda item: item.ItemId == newEntry.ItemId, fetchMetaData()))[0]

    items.entries.append(newEntry)
    items.user.append(newUser)
    items.meta.append(newMeta)

    return items


def printTableEntry(entryList: list[Any]) -> None:
    print("\n--------------------\n".join(map(repr, entryList)))

#generates the functions that print user, meta, info entry tables
for l in ("user", "meta", "info"):
    exec(f"""
def action_{l}(items: Items) -> Items:
    '''\n\tPrints all loaded {l} entries\n\t'''
    return printTableEntry(items.{"entries" if l == "info" else l}) or items
    """, globals(), locals())

@setArgc(count=1)
def action_search(oldItems: Items, search: str):
    """
    Doees a search using the aio-limas search syntax
    """
    res = requests.get(f"{apiPath}/query-v3?search={quote_plus(search)}")
    try:
        items: list[Entry] = parseJsonL(res.text, Entry)
    except json.decoder.JSONDecodeError:
        return oldItems
    validItemIds = {x.ItemId for x in items}
    user = filter(lambda x: x.ItemId in validItemIds, oldItems.user)
    meta = filter(lambda x: x.ItemId in validItemIds, oldItems.meta)
    return Items(entries=items, user=list(user), meta=list(meta)).orderizeLists()

action_s = action_search

def action_clear(_: Items):
    """
    Clears all loaded items
    """
    return Items()

def action_count(items: Items):
    """
    Prints the number of loaded entries
    """
    return print(len(items.entries)) or items

def confirmation_action_loop(items: Items, endPoint: str, shortName: str):
    beginAll = False
    for item in items.entries:
        if not beginAll:
            areYouSure = input(f"Are you sure you want to {shortName}: {item.En_Title} ({item.Type}) [y/a/s/N]: ").lower()
            if areYouSure == "a":
                beginAll = True
            elif areYouSure == "s":
                break
            elif areYouSure != "y":
                continue

        res = requests.get(f"{apiPath}{endPoint}?id={item.ItemId}")
        if res.status_code != 200:
            print(f"error: ({res.status_code}) {res.text}")
    return items

#generates the action_<action> functions, they all do the same thing
for action in ("begin", "finish", "plan", "pause", "resume", "drop"):
    plural = f'{action}{"e" * action.endswith("h")}s'
    docStr = f"{plural.title()} all loaded entries"
    exec(f"""
def action_{action}(items: Items):
\t'''\n\t{docStr}\n\t'''
\treturn confirmation_action_loop(items, "/engagement/{action}-media", "{action}")""", globals(), locals())


def action_ls(items: Items):
    """
    Lists all loaded entry's title,

    prints the en_title, if there is no en title, prints the user's specified native_title
    """
    return print("\n".join(i.En_Title or i.Native_Title for i in items.entries)) or items

def action_i(items: Items):
    """
    Interactive mode
    """
    while (action := input(">> ")):
        action, *actionArgs = action.split(" ")
        argC = get_action_argc(action)
        fn = get_action_fn(action)
        if len(actionArgs) < argC:
            fnArgList = inspect.getfullargspec(fn)[0]
            print(f"Not enough arguments for {action}, expected {", ".join(fnArgList[1:])}")
            continue
        while len(actionArgs) > argC:
            actionArgs[-1] = actionArgs[-2] + " " + actionArgs.pop()
        items = do_action(items, action, actionArgs)
    return items

@setArgc(count=1)
def action_help(items: Items, action: str):
    """
    Gets help reguarding an action

    Use the `actions` action to list all actions
    """
    fn = get_action_fn(action)
    print(fn.__doc__ if fn else f"Invalid action {action}, use the `actions` action to list all actions")
    return items

def action_actions(items: Items):
    """
    Lists all actions
    """
    g = globals()
    for name in filter(lambda name: name.startswith("action_") and "invalid" not in name, g):
        print(name[len("action_"):], g[name].__doc__, sep="\n", end="--------------------\n")
    return items

def action_invalid_action(items: Items):
    """
    Invalid action
    """
    print(f"Invalid action: {getattr(action_invalid_action, "_aio_action")}")
    return items

@setArgc(count=1)
def action_af(items: Items, filter: str):
    """
    Gets all items then filters based on a filter
    """
    return action_filter(action_all(items), filter)

def action_as(items: Items):
    """
        Gets all items then runs select
    """
    return action_select(action_all(items))

def get_action_fn(name: str):
    return globals().get(f"action_{name}", action_invalid_action)

def get_action_argc(action: str):
    fn = get_action_fn(action)
    if hasattr(fn, "_aio_argc"):
        return getattr(fn, "_aio_argc")
    return 0

def do_action(items: Items, action: str, args: list[Any]):
    fn = get_action_fn(action)
    setattr(fn, "_aio_action", action)
    return fn(items, *args)

i = 0
while (i := i + 1) < len(args):
    action = args[i]
    argC = get_action_argc(action)
    fn = get_action_fn(action)
    if i + argC >= len(args):
        fnArgList = inspect.getfullargspec(fn)[0]
        print(f"Not enough arguments for {action}, expected {", ".join(fnArgList[1:])}")
        continue
    actionArgs = [args[j] for j in range(i + 1, i + 1 + argC)]
    items = do_action(items, action, actionArgs)
    i += argC

for itemText in map(lambda x: repr(x), items.entries):
    longestLine = sorted(len(x) for x in itemText.split("\n"))[-1]
    print(itemText, end=f"\n{"-" * longestLine}\n\n")
